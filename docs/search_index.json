[["tidy.html", "4 Tidy 4.1 Datos 4.2 Pivotar 4.3 Separar y unir 4.4 Lidiar con los datos faltantes 4.5 Case study", " 4 Tidy 4.1 Datos Vamos a trabajar con unos datos sencillos que recopilan la misma información sobre 4 variables: país (country), año (year), población (population) y casos (cases) de Tuberculosis (TB). ¿Puedes identificar cuál de ellos está en forma tidy? library(tidyverse) ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── ## ✔ dplyr 1.1.2 ✔ readr 2.1.4 ## ✔ forcats 1.0.0 ✔ stringr 1.5.0 ## ✔ ggplot2 3.4.2 ✔ tibble 3.2.1 ## ✔ lubridate 1.9.2 ✔ tidyr 1.3.0 ## ✔ purrr 1.0.1 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() ## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors table1 ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 table2 ## # A tibble: 12 × 4 ## country year type count ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## 4 Afghanistan 2000 population 20595360 ## 5 Brazil 1999 cases 37737 ## 6 Brazil 1999 population 172006362 ## 7 Brazil 2000 cases 80488 ## 8 Brazil 2000 population 174504898 ## 9 China 1999 cases 212258 ## 10 China 1999 population 1272915272 ## 11 China 2000 cases 213766 ## 12 China 2000 population 1280428583 table3 ## # A tibble: 6 × 3 ## country year rate ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 table4a ## # A tibble: 3 × 3 ## country `1999` `2000` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 table4b ## # A tibble: 3 × 3 ## country `1999` `2000` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 19987071 20595360 ## 2 Brazil 172006362 174504898 ## 3 China 1272915272 1280428583 4.2 Pivotar Generalmente, para ordenar tus datos (tidying) tendrás que seguir 2 pasos básicos: Identificar qué es variable (lo que irá en las columnas) y qué es observación (lo que irá en las filas); Resolver una de estas situaciones: Las variables podrían estar distribuidas en varias columnas Las observaciones podrían estar distribuidas en varias filas Ambas a la vez :( Esto lo resolveremos con las funciones pivot_longer() y pivot_wider(). 4.2.1 Pivot longer Cuando nuestro dataset tiene por columnas los valores de una variable, usamos pivot_longer(). La table4a es un caso claro de esta situación: tenemos dos columnas con nombre 1990 y 2000, que corresponden a valores de la variable year. El proceso para hacerlos tidy pasa por arreglar estas columnas creando dos nuevas variables: year y cases: table4a %&gt;% pivot_longer(c(`1999`, `2000`), names_to = &quot;year&quot;, values_to = &quot;cases&quot;) ## # A tibble: 6 × 3 ## country year cases ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 745 ## 2 Afghanistan 2000 2666 ## 3 Brazil 1999 37737 ## 4 Brazil 2000 80488 ## 5 China 1999 212258 ## 6 China 2000 213766 De forma similar, podemos arreglar table4b: table4b %&gt;% pivot_longer(c(`1999`, `2000`), names_to = &quot;year&quot;, values_to = &quot;population&quot;) ## # A tibble: 6 × 3 ## country year population ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 19987071 ## 2 Afghanistan 2000 20595360 ## 3 Brazil 1999 172006362 ## 4 Brazil 2000 174504898 ## 5 China 1999 1272915272 ## 6 China 2000 1280428583 Finalmente, si queremos unir ambos resultados, podemos usar left_join, que ya estudiaremos con los Datos relacionales: tidy4a &lt;- table4a %&gt;% pivot_longer(c(`1999`, `2000`), names_to = &quot;year&quot;, values_to = &quot;cases&quot;) tidy4b &lt;- table4b %&gt;% pivot_longer(c(`1999`, `2000`), names_to = &quot;year&quot;, values_to = &quot;population&quot;) left_join(tidy4a, tidy4b) ## Joining with `by = join_by(country, year)` ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 4.2.2 Pivot wider Lo opuesto a alargar un dataset es hacerlo más ancho. Por tanto, es de entender que con pivot_wider() crearemos más columnas. Si prestamos atención a la table2 notaremos que cada observación ha sido expandida en dos filas que recogen los casos y la población. Esto lo solucionamos creando dos nuevas variables (columnas) para los casos y la población: table2 %&gt;% pivot_wider(names_from = type, values_from = count) ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 4.2.3 Ejercicios Aunque opuestas, no son perfectamente simétricas. ¿Puedes deducir por qué? stocks &lt;- tibble( year = c(2015, 2015, 2016, 2016), half = c( 1, 2, 1, 2), return = c(1.88, 0.59, 0.92, 0.17) ) stocks %&gt;% pivot_wider(names_from = year, values_from = return) %&gt;% pivot_longer(`2015`:`2016`, names_to = &quot;year&quot;, values_to = &quot;return&quot;) Intenta arreglarlo usando el argumento names_transform = list(year = as.numeric ). ¿Por qué esto no funciona? table4a %&gt;% pivot_longer(c(1999, 2000), names_to = &quot;year&quot;, values_to = &quot;cases&quot;) ¿Qué pasa si ampliamos esta tabla? people &lt;- tribble( ~name, ~names, ~values, #-----------------|--------|------ &quot;Phillip Woods&quot;, &quot;age&quot;, 45, &quot;Phillip Woods&quot;, &quot;height&quot;, 186, &quot;Phillip Woods&quot;, &quot;age&quot;, 50, &quot;Jessica Cordero&quot;, &quot;age&quot;, 37, &quot;Jessica Cordero&quot;, &quot;height&quot;, 156 ) usando el comando: pivot_wider(people, names_from=&quot;name&quot;, values_from = &quot;values&quot;) 4.3 Separar y unir La table3 tiene una columna rate con los casos y la población. Evidentemente, esta proporción no es realmente útil porque no está calculada. Con separate() podemos “partirla” en dos nuevas columnas con la información que deseamos: table3 %&gt;% separate(rate, into = c(&quot;cases&quot;, &quot;population&quot;)) ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Automáticamente, la función separa los datos cuando encuentra algún caracter no alfanumérico. Esto se puede personalizar: table3 %&gt;% separate(rate, into = c(&quot;cases&quot;, &quot;population&quot;), sep = &quot;/&quot;) ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Habrás notado que al separar convierte las nuevas a variables a tipo character. Para lidiar con esto, podemos decirle a separate que encuentre el tipo de datos correspondiente a cada caso: table3 %&gt;% separate(rate, into = c(&quot;cases&quot;, &quot;population&quot;), convert = TRUE) ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 También podemos separar enteros si proporcionamos el número de dígitos a separar: table3 %&gt;% separate(year, into = c(&quot;first_3&quot;, &quot;last_digit&quot;), sep = -1) %&gt;% separate(rate, into = c(&quot;cases&quot;, &quot;population&quot;), convert = TRUE) ## # A tibble: 6 × 5 ## country first_3 last_digit cases population ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 199 9 745 19987071 ## 2 Afghanistan 200 0 2666 20595360 ## 3 Brazil 199 9 37737 172006362 ## 4 Brazil 200 0 80488 174504898 ## 5 China 199 9 212258 1272915272 ## 6 China 200 0 213766 1280428583 table3 %&gt;% separate(year, into = c(&quot;century&quot;, &quot;year&quot;), sep = 2) %&gt;% separate(rate, into = c(&quot;cases&quot;, &quot;population&quot;), convert = TRUE) ## # A tibble: 6 × 5 ## country century year cases population ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 19 99 745 19987071 ## 2 Afghanistan 20 00 2666 20595360 ## 3 Brazil 19 99 37737 172006362 ## 4 Brazil 20 00 80488 174504898 ## 5 China 19 99 212258 1272915272 ## 6 China 20 00 213766 1280428583 Con unite() hacemos justamente lo contrario, especificando el separador (por defecto será _) que en este caso será un espacio en blanco: table5 %&gt;% unite(new, century, year, sep = &quot;&quot;) ## # A tibble: 6 × 3 ## country new rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 4.3.1 Ejercicios Experimenta con los argumentos extra y fill de separate(), usando estos datos: tibble(x = c(&quot;a,b,c&quot;, &quot;d,e,f,g&quot;, &quot;h,i,j&quot;)) %&gt;% separate(x, c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)) ## Warning: Expected 3 pieces. Additional pieces discarded in 1 rows [2]. ## # A tibble: 3 × 3 ## one two three ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 a b c ## 2 d e f ## 3 h i j tibble(x = c(&quot;a,b,c&quot;, &quot;d,e&quot;, &quot;f,g,i&quot;)) %&gt;% separate(x, c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)) ## Warning: Expected 3 pieces. Missing pieces filled with `NA` in 1 rows [2]. ## # A tibble: 3 × 3 ## one two three ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 a b c ## 2 d e &lt;NA&gt; ## 3 f g i 4.4 Lidiar con los datos faltantes Habrás notado que al cambiar la forma en que presentamos los datos, pueden aparecer valores perdidos (NAs). Estos perdidos pueden ser de dos formas: Explícitos, cuando vemos un NA en los datos. Implícitos, cuando no están presentes en los datos. ¿Podrías identificarlos aquí? stocks &lt;- tibble( year = c(2015, 2015, 2015, 2015, 2016, 2016, 2016), qtr = c( 1, 2, 3, 4, 2, 3, 4), return = c(1.88, 0.59, 0.35, NA, 0.92, 0.17, 2.66) ) Observa cómo los implícitos pasan a ser explícitos: stocks %&gt;% pivot_wider(names_from = year, values_from = return) ## # A tibble: 4 × 3 ## qtr `2015` `2016` ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1.88 NA ## 2 2 0.59 0.92 ## 3 3 0.35 0.17 ## 4 4 NA 2.66 Si hacemos la operación inversa con pivot_longer(), tal vez no deseamos que esos perdidos aparezcan de forma explícita: stocks %&gt;% pivot_wider(names_from = year, values_from = return) %&gt;% pivot_longer( cols = c(`2015`, `2016`), names_to = &quot;year&quot;, values_to = &quot;return&quot;, values_drop_na = TRUE ) ## # A tibble: 6 × 3 ## qtr year return ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 2015 1.88 ## 2 2 2015 0.59 ## 3 2 2016 0.92 ## 4 3 2015 0.35 ## 5 3 2016 0.17 ## 6 4 2016 2.66 Por otro lado, si queremos que los perdidos implícitos aparezcan de forma explícita (sí, ¡vaya lío!): stocks %&gt;% complete(year, qtr) ## # A tibble: 8 × 3 ## year qtr return ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2015 1 1.88 ## 2 2015 2 0.59 ## 3 2015 3 0.35 ## 4 2015 4 NA ## 5 2016 1 NA ## 6 2016 2 0.92 ## 7 2016 3 0.17 ## 8 2016 4 2.66 4.4.1 Ejercicios Otra función interesante es fill. ¿Puedes entender cómo funciona a partir de este ejemplo? treatment &lt;- tribble( ~ person, ~ treatment, ~response, &quot;Derrick Whitmore&quot;, 1, 7, NA, 2, 10, NA, 3, 9, &quot;Katherine Burke&quot;, 1, 4 ) treatment ## # A tibble: 4 × 3 ## person treatment response ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Derrick Whitmore 1 7 ## 2 &lt;NA&gt; 2 10 ## 3 &lt;NA&gt; 3 9 ## 4 Katherine Burke 1 4 treatment %&gt;% fill(person) ## # A tibble: 4 × 3 ## person treatment response ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Derrick Whitmore 1 7 ## 2 Derrick Whitmore 2 10 ## 3 Derrick Whitmore 3 9 ## 4 Katherine Burke 1 4 ¿Para qué sirve el argumento direction de fill()? 4.5 Case study Vamos con unos datos reales. En este caso, usaremos el dataset who de dplyr, con información sobre el número de casos de TB en el 2014, proporcionados por la Organización Mundial de la Salud (OMS, o WHO en inglés). data(&quot;who&quot;) El primer paso es crear una nueva columna auxiliar para agrupar las categorías new_sp_m014 a new_rel_f65, que no parecen ser variables: who1 &lt;- who %&gt;% pivot_longer( cols = new_sp_m014:newrel_f65, names_to = &quot;key&quot;, values_to = &quot;cases&quot;, values_drop_na = TRUE ) who1 ## # A tibble: 76,046 × 6 ## country iso2 iso3 year key cases ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Afghanistan AF AFG 1997 new_sp_m014 0 ## 2 Afghanistan AF AFG 1997 new_sp_m1524 10 ## 3 Afghanistan AF AFG 1997 new_sp_m2534 6 ## 4 Afghanistan AF AFG 1997 new_sp_m3544 3 ## 5 Afghanistan AF AFG 1997 new_sp_m4554 5 ## 6 Afghanistan AF AFG 1997 new_sp_m5564 2 ## 7 Afghanistan AF AFG 1997 new_sp_m65 0 ## 8 Afghanistan AF AFG 1997 new_sp_f014 5 ## 9 Afghanistan AF AFG 1997 new_sp_f1524 38 ## 10 Afghanistan AF AFG 1997 new_sp_f2534 36 ## # ℹ 76,036 more rows Antes de separar la columna key, de acuerdo a la información consultada en la ayuda ?who, tenemos que lidiar con unos typos muy difíciles de observar: hay cierta inconsistencia entre new_rel y newrel. Para resolver esto, solo tenemos que emplear una de las funciones de stringr… Arréglalo y guarda los datos en un nuevo tibble who2. ## # A tibble: 76,046 × 6 ## country iso2 iso3 year key cases ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Afghanistan AF AFG 1997 new_sp_m014 0 ## 2 Afghanistan AF AFG 1997 new_sp_m1524 10 ## 3 Afghanistan AF AFG 1997 new_sp_m2534 6 ## 4 Afghanistan AF AFG 1997 new_sp_m3544 3 ## 5 Afghanistan AF AFG 1997 new_sp_m4554 5 ## 6 Afghanistan AF AFG 1997 new_sp_m5564 2 ## 7 Afghanistan AF AFG 1997 new_sp_m65 0 ## 8 Afghanistan AF AFG 1997 new_sp_f014 5 ## 9 Afghanistan AF AFG 1997 new_sp_f1524 38 ## 10 Afghanistan AF AFG 1997 new_sp_f2534 36 ## # ℹ 76,036 more rows Ahora vamos a hacer dos pases de separate() . Primero, separamos todo lo que esté unido por _: who3 &lt;- who2 %&gt;% separate(key, c(&quot;new&quot;, &quot;type&quot;, &quot;sexage&quot;), sep = &quot;_&quot;) who3 ## # A tibble: 76,046 × 8 ## country iso2 iso3 year new type sexage cases ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Afghanistan AF AFG 1997 new sp m014 0 ## 2 Afghanistan AF AFG 1997 new sp m1524 10 ## 3 Afghanistan AF AFG 1997 new sp m2534 6 ## 4 Afghanistan AF AFG 1997 new sp m3544 3 ## 5 Afghanistan AF AFG 1997 new sp m4554 5 ## 6 Afghanistan AF AFG 1997 new sp m5564 2 ## 7 Afghanistan AF AFG 1997 new sp m65 0 ## 8 Afghanistan AF AFG 1997 new sp f014 5 ## 9 Afghanistan AF AFG 1997 new sp f1524 38 ## 10 Afghanistan AF AFG 1997 new sp f2534 36 ## # ℹ 76,036 more rows Antes del segundo pase, elimina lo que no te interesa: new, iso2 e iso3. Cuando lo hayas hecho, guarda los nuevos datos en who4, y hacemos al segundo separate() para obtener el sexo y rangos de edades por separado: who5 &lt;- who4 %&gt;% separate(sexage, c(&quot;sex&quot;, &quot;age&quot;), sep = 1) who5 ## # A tibble: 76,046 × 6 ## country year type sex age cases ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Afghanistan 1997 sp m 014 0 ## 2 Afghanistan 1997 sp m 1524 10 ## 3 Afghanistan 1997 sp m 2534 6 ## 4 Afghanistan 1997 sp m 3544 3 ## 5 Afghanistan 1997 sp m 4554 5 ## 6 Afghanistan 1997 sp m 5564 2 ## 7 Afghanistan 1997 sp m 65 0 ## 8 Afghanistan 1997 sp f 014 5 ## 9 Afghanistan 1997 sp f 1524 38 ## 10 Afghanistan 1997 sp f 2534 36 ## # ℹ 76,036 more rows 4.5.1 Ejercicios Escribe todas las transformaciones con un único pipe. Para cada país, año y sexo calcula el número total de casos de TB. Haz un plot de los resultados, de la forma que consideres más informativa. Guarda el último de tus data.frames o tibbles usando un formato de R. Estos datos los utilizaremos más adelante… "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
